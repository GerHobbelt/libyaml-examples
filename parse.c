/*
 * Example libyaml parser.
 *
 * This is a basic example to demonstrate how to convert yaml to raw data
 * using the libyaml emitter API. Example yaml data to be parsed:
 *
 *    $ cat fruit.yaml
 *    ---
 *    fruit:
 *    - name: apple
 *      color: red
 *      count: 12
 *    - name: orange
 *      color: orange
 *      count: 3
 *    - name: bannana
 *      color: yellow
 *      count: 4
 *    - name: mango
 *      color: green
 *      count: 1
 *    ...
 *
 *    $ ./parse < fruit.yaml
 *    name=apple, color=red, count=12
 *    name=orange, color=orange, count=3
 *    name=bannana, color=yellow, count=4
 *    name=mango, color=green, count=1
 *
 * See the libyaml project page http://pyyaml.org/wiki/LibYAML
 */
#include <yaml.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "fruit.h"

/* Set environment variable DEBUG=1 to enable debug output. */
int debug = 0;

/* yaml_* functions return 1 on success and 0 on failure. */
enum status {
    SUCCESS = 1,
    FAILURE = 0
};

/* Our example parser states. */
enum state {
    STATE_START,
    STATE_STREAM,
    STATE_DOCUMENT,
    STATE_SECTION,
    STATE_LIST,
    STATE_VALUES,
    STATE_KEY,
    STATE_VALUE,
    STATE_STOP
};

/* Supported yaml keys. */
enum key {
    KEY_FRUIT,
    KEY_NAME,
    KEY_COLOR,
    KEY_COUNT
};

/* Our application parser state data. */
struct parser_state {
    enum state state;      /* The current parse state */
    enum key key;          /* Last key name seen. */
    struct fruit f;        /* Fruit data elements seen. */
    struct fruits flist;   /* List of 'fruit' objects seen. */
};

/*
 * Consume yaml events generated by the libyaml parser to
 * import our data into raw c data structures. Error processing
 * is keep to a mimimum since this is just an example.
 *
 * The expected sequence of events is:
 *
 *    stream ::= STREAM-START document* STREAM-END
 *    document ::= DOCUMENT-START section* DOCUMENT-END
 *    section ::= MAPPING-START ("fruit" list) MAPPING-END
 *    list ::= SEQUENCE-START values* SEQUENCE-END
 *    values ::= MAPPING-START (key value)* MAPPING-END
 *    key ::= "name" | "color" | "count"
 *    value ::= SCALAR
 *
 * For example:
 *
 *    stream-start-event
 *      document-start-event
 *        mapping-start-event
 *          scalar-event={value="fruit", length=5}
 *          sequence-start-event
 *            mapping-start-event
 *              scalar-event={value="name", length=4}
 *              scalar-event={value="apple", length=5}
 *              scalar-event={value="color", length=5}
 *              scalar-event={value="red", length=3}
 *              scalar-event={value="count", length=5}
 *              scalar-event={value="12", length=2}
 *            mapping-end-event
 *            mapping-start-event
 *              scalar-event={value="name", length=4}
 *              scalar-event={value="orange", length=6}
 *              scalar-event={value="color", length=5}
 *              scalar-event={value="orange", length=6}
 *              scalar-event={value="count", length=5}
 *              scalar-event={value="3", length=1}
 *            mapping-end-event
 *          sequence-end-event
 *        mapping-end-event
 *      document-end-event
 *    stream-end-event
 *
 */
int consume_event(struct parser_state *s, yaml_event_t *event)
{
    char *value;

    if (debug) {
        printf("state=%d event=%d\n", s->state, event->type);
    }
    switch (s->state) {
    case STATE_START:
        switch (event->type) {
        case YAML_STREAM_START_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;
     case STATE_STREAM:
        switch (event->type) {
        case YAML_DOCUMENT_START_EVENT:
            s->state = STATE_DOCUMENT;
            break;
        case YAML_STREAM_END_EVENT:
            s->state = STATE_STOP;  /* All done. */
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;
     case STATE_DOCUMENT:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_SECTION;
            break;
        case YAML_DOCUMENT_END_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;
    case STATE_SECTION:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "fruit") == 0) {
               s->state = STATE_LIST;
            } else {
               fprintf(stderr, "Unexpected scalar: %s\n", value);
               return FAILURE;
            }
            break;
        case YAML_DOCUMENT_END_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;
    case STATE_LIST:
        switch (event->type) {
        case YAML_SEQUENCE_START_EVENT:
            s->state = STATE_VALUES;
            break;
        case YAML_MAPPING_END_EVENT:
            s->state = STATE_SECTION;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;
    case STATE_VALUES:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_KEY;
            break;
        case YAML_SEQUENCE_END_EVENT:
            s->state = STATE_LIST;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;
    case STATE_KEY:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "name") == 0) {
                s->key = KEY_NAME;
            } else if (strcmp(value, "color") == 0) {
                s->key = KEY_COLOR;
            } else if (strcmp(value, "count") == 0) {
                s->key = KEY_COUNT;
            } else {
                fprintf(stderr, "Unexpected key: %s\n", value);
                return FAILURE;
            }
            s->state = STATE_VALUE;
            break;
        case YAML_MAPPING_END_EVENT:
            add_fruit(&s->flist, s->f.name, s->f.color, s->f.count);
            free(s->f.name);
            free(s->f.color);
            memset(&s->f, 0, sizeof(s->f));
            s->state = STATE_VALUES;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;
    case STATE_VALUE:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char*)event->data.scalar.value;
            if (s->key == KEY_NAME) {
                if (s->f.name) {
                    fprintf(stderr, "Warning: duplicate 'name' key.\n");
                    free(s->f.name);
                }
                s->f.name = bail_strdup(value);
            } else if (s->key == KEY_COLOR) {
                if (s->f.color) {
                    fprintf(stderr, "Warning: duplicate 'color' key.\n");
                    free(s->f.color);
                }
                s->f.color = bail_strdup(value);
            } else if (s->key == KEY_COUNT) {
                s->f.count = atoi(value);
            } else {
                fprintf(stderr, "Unknown key: %d\n", s->key);
                return FAILURE;
            }
            s->state = STATE_KEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;
    case STATE_STOP:
        break;
    }
    return SUCCESS;
}

int
main(int argc, char *argv[])
{
    enum status status;
    struct parser_state state;
    yaml_parser_t parser;
    yaml_event_t event;

    if (getenv("DEBUG")) {
        debug = 1;
    }

    memset(&state, 0, sizeof(state));
    state.state = STATE_START;
    yaml_parser_initialize(&parser);
    yaml_parser_set_input_file(&parser, stdin);
    do {
        status = yaml_parser_parse(&parser, &event);
        if (status == FAILURE) {
            fprintf(stderr, "yaml_parser_parse error\n");
            goto done;
        }
        status = consume_event(&state, &event);
        if (status == FAILURE) {
            fprintf(stderr, "consume_event error\n");
            goto done;
        }
        yaml_event_delete(&event);
    } while (state.state != STATE_STOP);

    /* Output the parsed data. */
    for (struct fruit *f = state.flist.head; f; f = f->next) {
        printf("name=%s, color=%s, count=%d\n", f->name, f->color, f->count);
    }

done:
    free(state.f.name);
    free(state.f.color);
    destroy_fruits(&state.flist);
    yaml_parser_delete(&parser);
    return (status == SUCCESS ? EXIT_SUCCESS : EXIT_FAILURE);
}
